\chapter{Projekt aplikacji}
\section{Strona internetowa}
	Do stworzenia strony zdecydowano się użyć frameworku Angular 8.
	Serwowana będzie ze środowiska uruchomieniowego Node.js.
	Projekt zbudowany jest z osobnych modułów dla każdej funkcjonalności.
	Widoki składane są z komponentów --- są to elementy zawierające szablon HTML, style CSS oraz logikę i dane w klasie napisanej w języku typescript.
	Dodatkowo komponenty mogą korzystać z serwisów. Serwisy to specjalne klasy, które są wstrzykiwane jako zależności (ang \emph{Dependency injection}).
	Zawierają się w nich dane oraz logika dzielone między wieloma komponentami.
	Nawigacja pomiędzy poszczególnymi widokami odbywa się przy pomocy dedykowanego routera, który przechwytuje nawigację przeglądarki.
	Dzięki temu nawet nawigacja do tyłu nie powoduje przeładowania całej strony tylko poszczególnych zmienionych elementów.

	Do budowy widoków użyta zostanie biblioteka Angular Material,
	która zawiera często wykorzystywane elementy zbudowane zgodnie z oficjalną specyfikacją \emph{Material design}.

	Taka modularna architektura pozwala na wielokrotne używanie tych samych komponentów oraz na zachowanie czytelnej struktury kodu.

\section{Serwis API}
	Projekt podzielony zostanie na trzy warstwy:
	\begin{description}
		\item[Api] warstwa obsługująca zapytania GraphQL
		\item[Core] warstwa domenowa definiująca modele encji oraz interfejsy, z których korzysta warstwa Api
		\item[Infrastructure] warstwa implementująca interfejsy oraz obsługująca dostęp do bazy danych
	\end{description}

	Podział ten znany jest jako ,,czysta architektura'' (ang.\ \emph{Clean architecture}).
	Taki układ umożliwia podział projektu na warstwy, które mają zdefiniowane odpowiedzialności.
	Dzięki zachowaniu zasady odwrócenia zależności możliwe jest testowanie każdej funkcjonalności z osobna.

	% obrazek clean architecture z przepływem zapytania (MS coś miał)

	Na platformie \@.Net Core dostępne są dwie aktywnie rozwijane biblioteki implementujące GraphQL\@: \emph{GraphQL \@.NET} oraz \emph{Hot Chocolate}.
	Mimo znacznie mniejszej popularności wybrana została biblioteka \emph{Hot Chocolate},
	ponieważ prezentuje wiele możliwości automatyzacji generowania schematu GraphQL\@ oraz analizowania zapytań.

	Z racji tego, że GraphQL jest protokołem służącym do przesyłania danych, jest on zaimplementowany w najwyższej warstwie serwisu -- Api.
	W związku z tym nie zawęża sposobu implementacji zapisu danych w warstwie infrastruktury,
	a więc nic nie stoi na przeszkodzie, aby użyć relacyjnej bazy SQL.
	Takie rozwiązanie umożliwia wykorzystanie zalet relacyjnych baz - integralność i niezależność danych,
	jednocześnie oferując grafowy odczyt danych poprzez GraphQL.

\section{Baza danych}
	Baza danych stworzona zostanie w systemie zarządzania relacyjną bazą danych PostgreSQL.
	Jest to open source'owe oprogramowanie, obecnie jeden z najlepiej rozwiniętych RDBMS-ów.

	% diagram ERD
	

\section{Uwierzytelnianie}
	Jako protokół uwierzytelniania wybrano OpenID Connect.
	Standard ten rozszerza OAuth2 (służący do autoryzacji) o warstwę identyfikacji użytkowników.
	Jest obecnie jednym z najbezpieczniejszych standardów uwierzytelniania.
	Zaimplementowany zostanie przy pomocy biblioteki \emph{IdentityServer4} na platformie \emph{ASP.Net Core 3.0}.
	Użytkownik po zalogowaniu otrzyma token JWT, który będzie zawierał cyfrową sygnaturę.
	Dzięki temu jakakolwiek ingerencja w jego strukturę sprawi, iż nie jego walidacja zakończy się niepowodzeniem.

	% OBRAZEK PKCE FLOW
