\chapter{Implementacja}
\label{sec:implementacja}

\section{Docker}
	Do zbudowania aplikacji użyto narzędzia \emph{docker-compose}.
	Pozwala ono definiować kontenery, które uruchomione zostaną we wspólnym środowisku.
	Dla każdego kontenera zdefiniowane zostały następujące właściwości:
	\begin{description}
		\item[container\_name] nazwa kontenera
		\item[image] obraz, z którego będzie zbudowany
		\item[build] instrukcje do zbudowania obrazu
		\item[networks] wewnętrzne sieci, do których podłączony zostanie kontener
		\item[volumes] foldery hosta, które zostaną zmapowane do adresu wewnątrz kontenera
		\item[ports] porty hosta, które zostaną zmapowane na porty kontenera
		\item[environment] zmienne środowiskowe wewnątrz kontenera
		\item[depends\_on] kontenery, które powinny zostać zbudowane przed opisywanym kontenerem
	\end{description}
	Każdy kontener musi mieć zdefiniowany \textbf{image}, z którego zostanie zbudowany
	lub parametry \textbf{build} z adresem pliku Dockerfile zawierającym przepis na zbudowanie obrazu.
	
	Pliki docker-compose są przyłączeniowe; podczas budowania środowiska można zdefiniować więcej niż jeden.
	Zaletę tę wykorzystano w projekcie i rozdzielono pliki docker-compose na wersje odpowiadające odpowiednim środowiskom.
	Proces budowania środowiska przedstawiony zostanie na przykładzie kontenera \verb|authServer|.

	\subsection{Budowanie środowiska: docker-compose}
		We fragmencie kodu~\ref{lst:docker-compose} przedstawiono ustawienia wspólne dla wszystkich środowisk.
		Znajduje się tu nazwa kontenera, nazwa wynikowego obrazu, sieć do której jest podłączony oraz kontenery, od których jest zależny.
		Sieć \verb|mainNetwork| jest wspólna dla wszystkich kontenerów.
		Określona jest zależność od kontenera \verb|mainDB|, ponieważ serwis korzysta z bazy od razu przy uruchomieniu serwera.

		\begin{lstlisting}[label=lst:docker-compose,caption=Wspólne ustawienia kontenera authServer]
			authserver:
				container_name: "authServer"
				image: ${DOCKER_REGISTRY-}authserver
				networks:
					- "mainNetwork"
				depends_on:
					- "maindb"
		\end{lstlisting}

		Natomiast fragment~\ref{lst:docker-compose.override} zawiera ustawienia tego samego kontenera dla środowiska developerskiego.
		Zdefiniowane zostały następujące zmienne środowiskowe:
		\begin{description}
			\item[ENABLE\_POLLING] wykorzystywana w Dockerfile, określa czy kontener zostanie przebudowany po każdych zmianach w plikach źródłowych
			\item[ASPNETCORE\_ENVIRONMENT] wykorzystywana jest wewnątrz programu do określenia odpowiednich konfiguracji
			\item[ASPNETCORE\_URLS] adresy wykorzystywane przez serwer, adres HTTPS (443) nie jest wymieniony, ponieważ szyfrowaniem zajmuje się kontener z odwróconym proxy
			\item[ConnectionStrings\_\_DefaultConnection] ustawienia połączenia do bazy, wykorzystywany jest wewnętrzny adres kontenera \verb|mainDB|
		\end{description}
		Kontener posiada osobne pliki Dockerfile dla każdego środowiska, ponieważ w środowisku developerskim zaimplementowano obserwowanie plików źródłowych.
		Dzięki temu, każda zmiana w kodzie skutkuje natychmiastowym przebudowaniem kontenera, co znacznie przyspiesza pracę.
		Treść pliku Dockerfile (listing~\ref{lst:dockerfile}) została dokładnie opisana w następnym rozdziale.
		W tym środowisku wszystkie kontenery mają również zmapowane porty na zewnątrz.
		Folder z kodem źródłowym został zmapowany na adres \verb|/app|, co również podyktowane jest wykrywaniem zmian w plikach.

		\begin{lstlisting}[label=lst:docker-compose.override,caption=Ustawienia kontenera authServer dla środowiska developerskiego]
			authserver:
				environment:
					- ENABLE_POLLING=1
					- ASPNETCORE_ENVIRONMENT=Development
					- ASPNETCORE_URLS=http://+:80
					- ConnectionStrings__DefaultConnection=Server=mainDB;Port=5432; ...
				build:
					context: .
					dockerfile: AuthServer/Dockerfile
				ports:
					- "5550:80"
				volumes:
					- "./AuthServer/:/app"
		\end{lstlisting}

	\subsection{Budowanie kontenera: Dockerfile}
	\label{sec:Dockerfile}

		Często do utworzenia serwisu wystarczy gotowy obraz dostępny w Docker Hub.
		Jest to największy serwis typu Docker Registry: baza udostępnionych obrazów dockerowych przygotowanych przez użytkowników, grupy czy firmy.
		Takie rozwiązanie jest wystarczające w przypadku kontenera \verb|revProxy|.
		Obraz \verb|nginx| zawiera całą potrzebną funkcjonalność.

		We wszystkich pozostałych przypadkach wymagane jest utworzenie pliku Dockerfile, który określa przepis na zbudowanie obrazu.
		Zwykle nie buduje się całego obrazu od zera, lecz określa się inny obraz jako bazę i dopisuje się brakującą funkcjonalność.
		Jest to możliwe dzięki warstwowej budowie obrazów.
		W każdym obrazie zapisane są tylko zmiany w stosunku do obrazu bazowego,
		co pozwala na przechowywanie ogromnej liczby obrazów w serwisach typu Docker Registry.
		Przykładowo, obraz używany w kontenerze \verb|mainDB| rozszerza obraz \verb|postgres| w wersji 11.5 o zaledwie dwie komendy:
		\begin{lstlisting}[label=lst:mainDB-Dockerfile]
			FROM postgres:11.5
			RUN echo "listen_addresses='*'" >> /var/lib/postgresql/postgresql.conf
			EXPOSE 5432
		\end{lstlisting}
		komenda \verb|RUN| wywołuje podaną komendę w środku kontenera, natomiast komenda \verb|EXPOSE| aktywuje nasłuchiwanie na danym porcie.

		Nieco bardziej skomplikowany jest Dockerfile budujący serwis \verb|authServer| dla środowiska developerskiego,
		rozszerzający plik z projektu Dispersia/Dotnet-Watch-Docker-Example~\cite{dotnetWatch} o mechanizm wyłączania obserwowania z poziomu docker-compose:
		\begin{lstlisting}[label=lst:dockerfile,caption=Plik Dockerfile dla środowiska developerskiego]
			FROM mcr.microsoft.com/dotnet/core/sdk:3.0

			WORKDIR /vsdbg
			
			RUN apt-get update \
					&& apt-get install -y --no-install-recommends \
									unzip \
					&& rm -rf /var/lib/apt/lists/* \
					&& curl -sSL https://aka.ms/getvsdbgsh \
							| bash /dev/stdin -v latest -l /vsdbg
			
			ENV DOTNET_USE_POLLING_FILE_WATCHER ${ENABLE_POLLING:-0}
			
			WORKDIR /app
			
			ENTRYPOINT dotnet ${ENABLE_POLLING:+watch} run --urls=http://+:80		
		\end{lstlisting}
		
		W pierwszym kroku za pomocą \verb|WORKDIR| ustawiany jest folder, względem którego wykonywane będą wszystkie komendy.
		Następnie instalowany jest debugger .NET Core, który umożliwia debugowanie z Visual Studio na systemie hosta (Windows).
		Zmienna \verb|DOTNET_USE_POLLING_FILE_WATCHER| ustawiana jest na podstawie zmiennej \verb|ENABLE_POLLING| skonfigurowanej w docker-compose.
		Po zmianie katalogu roboczego na \verb|/app| ustawiana jest komenda uruchamiana po starcie kontenera.
		Ona również jest zależna od zmiennej \verb|ENABLE_POLLING|: jeśli zmienna jest ustawiona na 1, uruchomiona zostanie komenda \verb|dotnet watch run|.
		W przeciwnym wypadku będzie to komenda \verb|dotnet run|.

		Produkcyjny Dockerfile (listing~\ref{lst:dockerfile.prod}) nie obsługuje debugowania i optymalizowany jest pod względem wydajności.
		Wykorzystuje w tym celu warstwową naturę obrazów dockerowych.
		Jako bazy wykorzystuje warianty \verb|buster-slim| oraz \verb|buster| obrazów,
		które stworzone zostały specjalnie w tym celu.
		Został opracowany przez grupę tworzącą .NET Core.

		\begin{lstlisting}[label=lst:dockerfile.prod,caption=Plik Dockerfile budowany warstwowo]
			FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-buster-slim AS base
			WORKDIR /app
			EXPOSE 80
			
			FROM mcr.microsoft.com/dotnet/core/sdk:3.0-buster AS build
			WORKDIR /src
			COPY ["AuthServer/AuthServer.csproj", "AuthServer/"]
			RUN dotnet restore "AuthServer/AuthServer.csproj"
			COPY . .
			WORKDIR "/src/AuthServer"
			RUN dotnet build "AuthServer.csproj" -c Release -o /app/build
			
			FROM build AS publish
			RUN dotnet publish "AuthServer.csproj" -c Release -o /app/publish
			
			FROM base AS final
			WORKDIR /app
			COPY --from=publish /app/publish .
			ENTRYPOINT ["dotnet", "AuthServer.dll"]		
		\end{lstlisting}

\section{Strona internetowa}
	\subsection{Zastosowane technologie}
		Zgodnie z projektem, strona stworzona została w Angularze.
		Oprócz podstawowych bibliotek wykorzystane zostały następujące pakiety:
		\begin{description}
			\item[apollo] --- wiodący klient GraphQL. Oprócz implementacji protokołu GraphQL,
				zapewnia również zarządzanie pamięcią podręczną (ang.\ \emph{cache}) oraz stanem aplikacji (ang.\ \emph{state management}).
				Dzięki temu wszystkie wszystkie odpowiedzi z serwisu Api są zapamiętywane,
				co pozwala na stworzenie aplikacji działającej szybko nawet przy słabym połączeniu z internetem.
			
			\item[flex-layout] --- biblioteka stworzona przez zespół tworzący Angulara, umożliwiająca stworzenie responsywnego interfejsu.
				Dostarcza API wykorzystujące pod spodem media query, które pozwala na definiowanie struktury elementów HTML zależnej od rozmiaru ekranu.
				Dzięki temu interfejs automatycznie dostosowuje się np. do ekranu telefonu komórkowego.
			
			\item[oidc-client] --- biblioteka implementująca protokół OpenID Connect oraz OAuth2.
				Zapewnia klasy obsługujące proces logowania oraz zarządzania tokenami.

			\item[rxjs] --- implementacja ReactiveX na JavaScript.
				Łączy w sobie najlepsze pomysły ze wzorców projektowych \emph{Observer}, \emph{Iterator} oraz z programowania funkcyjnego~\cite{reactiveX}.
				Umożliwia programowanie przy pomocy obserwowalnych obiektów aby ułatwić tworzenie asynchronicznych strumieni.
		\end{description}

	\subsection{Klient GraphQL}
		Klient Apollo zbudowany został z opcjami przedstawionymi na listingu~\ref{lst:apolloSettings}.
		Jako adres Api Graphql użyto względnego uri wykorzystującego adres zdefiniowany w odwróconym proxy.
		W domyślnych ustawieniach zdefiniowano nagłówek autoryzujący pobierający Access Token zalogowanego użytkownika z serwisu \verb|AuthService|.
		Dzięki temu tożsamosć użytkownika może zostać zweryfikowana po stronie serwera.
		W tym miejscu zapisywane są również domyślne ustawienia aplikacji w \verb|InMemoryCache|, cache przetrzymywanym w pamięci przeglądarki.
		Uwarunkowane jest to tym, że ustawienia aplikacji nie są przetrzymywane w bazie danych.
		Możliwe jest to dzięki temu, że biblioteka apollo pozwala na definiowanie lokalnego schematu GraphQL, który rozszerza schemat wykorzystywanego API.
		W ten sposób uzyskano zarządzanie stanem aplikacji bez wykorzystywania dodatkowych bilbiotek typu \emph{NgRx} czy \emph{Redux}.
		\begin{lstlisting}[label=lst:apolloSettings, caption=Globalne ustawienia modułu Apollo, float]
			const uri = 'api/graphql';

			@NgModule({
				exports: [ApolloModule, HttpLinkModule],
				providers: [
					{
						provide: APOLLO_OPTIONS,
						useFactory: (httpLink: HttpLink, authService: AuthService) => {
							const auth = setContext((_operation, _context) => ({
								headers: {
									Authorization: authService.authorizationHeaderValue
								}
							}));
			
							const cache = new InMemoryCache();
			
							const defaultSettings = {
								__typename: 'Settings',
								theme: 'dark-theme'
							} as Settings;
							cache.writeData({data: {settings: defaultSettings}});
			
							return {
								link: ApolloLink.from([auth, httpLink.create({uri})]),
								cache,
								resolvers,
								typeDefs: {}
							};
						},
						deps: [HttpLink, AuthService]
					}
				]
			})
			export class GraphQLModule {}
		\end{lstlisting}

		\subsection*{Wywoływanie zapytań}
			W projekcie wykorzystano narzędzia \emph{graphql-cli} oraz \emph{graphql-codegen}.
			Pierwsze pozwala na generowanie lokalnej kopii dostępnego schematu za pomocą komendy \verb|graphql get-schema|.
			Drugi program generuje typy GraphQL jako interfejsy w języku TypeScript.
			Dodatkowo, konwertuje wszystkie zapytania oraz mutacje na serwisy angularowe, które mogą zostać wstrzyknięte do każdego komponentu.
			Dzięki temu tworząc zapytanie do Api, wystarczy napisać zapytanie w języku GraphQL, a narzędzie wygeneruje gotowy serwis.
			Przykładowo, napisanie następującego zapytania dodawającego nową ocenę albumu:
			\begin{lstlisting}
				mutation addRating($rating: RatingInput!) {
					addRating(rating: $rating) {
						id
					}
				}
			\end{lstlisting}
			wygeneruje następujący serwis:
			\begin{lstlisting}
				export const AddRatingDocument = gql`
					mutation addRating($rating: RatingInput!) {
						addRating(rating: $rating) {
							id
						}
					}
				`;
				
				@Injectable({
					providedIn: 'root'
				})
				export class AddRatingGQL
					extends Apollo.Mutation<AddRatingMutation, AddRatingMutationVariables> {
					document = AddRatingDocument;
				}
			\end{lstlisting}

			Klasa oznaczona jest angularowym dekoratorem \verb|@Injectable|, dzięki czemu dostępna jest jako serwis w całej aplikacji.
			Uzyskano w ten sposób szybki i elastyczny proces korzystania z Api jednocześnie zachowując pełną walidację typów.
			Serwis wystarczy zaimportować w komponencie i wywołać metodę \verb|mutate| zwracającą typ \verb|Observable|:
			\begin{lstlisting}
				constructor(
					private addRating: AddRatingGQL
				) {}

				rating: RatingInput;

				onSubmit() {
					this.addRating.mutate({rating: this.rating})
						.subscribe({
							error: err => console.log('mutation failed', err),
							complete: () => this.router.navigate(['/home'])
						});
				}
			\end{lstlisting}

			W aplikacji przyjęto założenia, że obiektów zwracanych przez mutację nie używa się bezpośrednio.
			Zwrócony obiekt aktualizuje cache, co powoduje, że wszystkie zasubskrybowane obiekty asynchronicznie otrzymują najnowszą wersję.
			Aby było to możliwe, elementy widoków utrymują subskrypcję przez cały cykl żywotności komponentu.
			Subskrypcja odbywa się automatycznie dzięki zasosowaniu \emph{async pipe}.
			\emph{Pipe} to klasa, która pozwalaja na transformację zadanego wejścia i używa się ich bezpośrednio w pliku HTML.
			Przykładowo, komponent wyświetlający dane albumu operuje na strumieniu zwracanym przez funkcję \verb|watch|:
			\begin{lstlisting}
				album$: Observable<GetAlbumFullQuery['album']>;

				constructor(
					private route: ActivatedRoute,
					private getAlbum: GetAlbumFullGQL
				) {}

				ngOnInit() {
					this.album$ = this.route.paramMap.pipe(
						switchMap((params: ParamMap) =>
							this.getAlbum.watch({id: params.get('id')}).valueChanges),
						map(res => res.data.album)
					);
				}
			\end{lstlisting}
			natomiast subskrypcja zarządzana jest w całości przez \emph{async pipe}:
			\begin{lstlisting}
				<div *ngIf="album$ | async as album">
					<h3>Title: {{album.title}}</h3>
				</div>
			\end{lstlisting}

		\subsubsection*{Lokalny schemat GraphQL}
			Jak przedstawiono na listingu~\ref{lst:schemaClient}, aby rozszerzyć typ o nowe pola należy użyć komendy \verb|extend|.
			W tym przypadku dodany został nowy typ \verb|Settings|, który jest użyty w dodatkowym polu domyślnego \verb|Query|.
			\begin{lstlisting}[label=lst:schemaClient, caption=Lokalny schemat GraphQL, float=th]
				extend type Query {
					settings: Settings
				}
				
				extend type Mutation {
					updateSettings(input: SettingsInput): Settings
				}
				
				type Settings {
					theme: String!
				}
				
				input SettingsInput {
					theme: String
				}
				
			\end{lstlisting}
			
			Wczytywanie danych zdefiniowanych w lokalnym schemacie odbywa się tak samo jak przy zewnętrznym Api z jedną różnicą:
			podczas definiowania zapytania należy użyć dyrektywy \verb|@client|, aby klient wiedział żeby nie odpytywać Api:
			\begin{lstlisting}
				query getSettings {
					settings @client {
						theme
					}
				}
			\end{lstlisting}

			Aby umożliwić zapisywanie danych do lokalnej bazy poprzez mutację \verb|updateSettings|,
			trzeba stworzyć \emph{resolver}, czyli funkcję, która określa działanie danego pola.
			\emph{Resolver} dla tej mutacji przedstawiony został we fragmencie kodu~\ref{lst:resolvers}.
			Tworzy on nowy obiekt typu \emph{Settings}, który oprócz przekazanych ustawień zawiera pole \verb|__typename|.
			Jest to pole identyfikujące obiekt, dzięki czemu cache nadpisze dane w odpowiednim miejscu.
			\begin{lstlisting}[label=lst:resolvers, caption=\emph{Resolvers} dla lokalnego cache, float=th]
				export const resolvers = {
					Mutation: {
						updateSettings: (_, {input}, {cache}) => {
							const settings = {
								__typename: 'Settings',
								...input
							} as Settings;
							cache.writeData({data: {settings}});

							return null;
						}
					}
				};
			\end{lstlisting}

	\subsection{Połączenie z Last.fm}
		W serwisie Last.fm zarejestrowano aplikację uzyskując dostęp do pełnego Api.
		Wykorzystywane jest tylko do pobierania publicznych danych, dlatego użytkownik aplikacji nie musi zakładać konta w serwisie.
		Z Api można korzystać zarówno w wersji XML, jak i JSON.
		W projekcie stworzono serwis wykorzystujący wersję JSON, definiując interfejsy dla każdego zapytania.
		Przykładowe zapytanie wykorzystujące metodę Api \verb|Artist.getTopAlbums| przedstawiono na listingu~\ref{lst:lastfmApi}.

		\begin{lstlisting}[label=lst:lastfmApi, caption=Metoda wykorzystujaca Api Last.fm, float]
			private readonly baseAddress = 'https://ws.audioscrobbler.com/2.0/';
			private apiParams = new HttpParams({
				fromObject: {
					api_key: this.apiKey,
					format: 'json',
					limit: '30'
				}
			});

			topByArtistSearch(query: string): Observable<LastFmAlbum[]> {
				return this.http
					.get<LastFmApiQueryResults>(this.baseAddress, {
						params: this.apiParams
							.set('method', LastFmApiMethod.TopByArtist)
							.set('artist', query)
							.set('autocorrect', '1')
					})
					.pipe(
						map(res => res.topalbums.album)
					);
			}
		\end{lstlisting}

	\subsection{Responsive design}
		Widoki aplikacji testowane były zarówno na ekranie Full HD, jak i o rozmiarze telefonu komórkowego (360px na 740px).
		Aby zapewnić wymaganą skalowalność interfejsu, elementy widoków zachowują się inaczej w zależności od szerokości ekranu.
		Atrybuty wykorzystujące responsywne API biblioteki \emph{flex-layout} wykorzystane zostały przy budowie nawigacji przedstawionej na listingu~\ref{lst:flexLayout}.
		Atrybut \verb|fxHide.gt-xs| chowa cały element jeśli rozmiar ekranu jest większy niż \verb|xs|.
		W ten sposób otrzymano toolbar, który dla zwykłych ekranów zawiera przyciski nawigacji (Rys.~\ref{fig:gt-xs}),
		a dla mniejszych przełącza menu boczne (Rys.~\ref{fig:xs}).
		Znaczenie aliasów wykorzystywanych do definiowania rozmiarów zamieszczono w tabeli~\ref{tab:flexLayoutApi}.

		\begin{lstlisting}[label=lst:flexLayout, caption=Menu nawigacji zależne od rozmiaru ekranu, float]
			<div fxHide.gt-xs>
				<button mat-icon-button (click)="onToggleSidenav()">
					<mat-icon>menu</mat-icon>
				</button>
			</div>

			<h1>{{appName}}</h1>
		
			<div fxFlex fxLayout="row" fxLayoutGap="10px" fxHide.xs>
				[...]
			</div>
		\end{lstlisting}

		\begin{table}[htb]
			\centering
			\caption{Zestawienie aliasów Api flex-layout z odpowiadającymi komendami mediaQuery~\cite{flexLayout}}
			\label{tab:flexLayoutApi}
			\begin{tabular}{|ll|} \hline
				Alias & mediaQuery \\ \hline\hline
				xs	&	'screen and (max-width: 599px)'	\\
				sm	&	'screen and (min-width: 600px) and (max-width: 959px)'	\\
				md	&	'screen and (min-width: 960px) and (max-width: 1279px)'	\\
				lg	&	'screen and (min-width: 1280px) and (max-width: 1919px)'	\\
				xl	&	'screen and (min-width: 1920px) and (max-width: 5000px)'	\\
					&		\\
				lt-sm	&	'screen and (max-width: 599px)'	\\
				lt-md	&	'screen and (max-width: 959px)'	\\
				lt-lg	&	'screen and (max-width: 1279px)'	\\
				lt-xl	&	'screen and (max-width: 1919px)'	\\
					&		\\
				gt-xs	&	'screen and (min-width: 600px)'	\\
				gt-sm	&	'screen and (min-width: 960px)'	\\
				gt-md	&	'screen and (min-width: 1280px)'	\\
				gt-lg	&	'screen and (min-width: 1920px)'	\\
				\hline
			\end{tabular}
		\end{table}

		\begin{figure}[ht]
			\centering
				\includegraphics[height=200px]{rys05/gt-xs.png}
			 \caption{Menu nawigacji dla zwykłych ekranów}
			 \label{fig:gt-xs}
		\end{figure}

		\begin{figure}[ht]
			\centering
				\includegraphics[height=200px]{rys05/xs.png}
			 \caption{Wysunięte manu nawigacji dla małych ekranów}
			 \label{fig:xs}
		\end{figure}

	\subsection{Przykładowy moduł}
		dodawanie recenzji

\section{GraphQL API}
	\subsection{Zastosowane technologie}
		\begin{description}
			\item[Hot Chocolate] 
			\item[Autofac] 
			\item[Entity Framework Core] 
			\item[Namotion.Reflection] 
			\item[Serilog] 
		\end{description}

	\subsection{Warstwa Api}

	\subsection{Warstwa domenowa}

	\subsection{Warstwa infrastrukturalna}
	
\section{Serwis uwierzytelniający}
	\subsection{Zastosowane technologie}
		Oprócz opisanych wcześniej \emph{Entity Framework Core} oraz \emph{Serilog} wykorzystane zostały:
		\begin{description}
			\item[IdentityServer4] 
			\item[AspNetCore.Identity] 
		\end{description}

	\subsection{Proces rejestracji i logowania}

	\subsection{Autoryzacja dostępu do API}

\section{Baza danych}

\section{Odwrócone proxy}